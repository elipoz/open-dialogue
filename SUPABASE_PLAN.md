# Supabase integration plan

## Overview

- Persist every conversation and its messages in Supabase.
- After the moderator enters their name, create a new conversation (UUID) and put it in the URL.
- Left panel: list previous conversations (by creation time); clicking one loads and shows that conversation (newest-first).
- All messages that appear in Conversation history are stored in Supabase.

---

## 1. Environment and dependency

- **Env:** You added `SUPABASE_KEY`; the Supabase Python client also needs **`SUPABASE_URL`** (e.g. `https://xxxx.supabase.co`). Add `SUPABASE_URL` to `.env`.
- **Dependency:** Add `supabase` to `pyproject.toml` (e.g. `supabase>=2.0.0`).

---

## 2. Database schema (Supabase)

Use **two tables** so we can list all conversations and load messages by conversation. (A literal “one table per conversation” named `od_<conversation_id>` would require dynamic DDL and makes “list all conversations” harder; the layout below gives the same behavior with standard schema.)

- **`od_conversations`** (metadata for each conversation)
  - `id` — UUID, primary key (the “conversation_id”).
  - `created_at` — timestamptz, set on insert (default `now()`).
  - Optionally: `moderator_name` (text) for display in the sidebar.

- **`od_messages`** (one row per message in Conversation history)
  - `id` — autogenerated (e.g. `bigserial` or `uuid default gen_random_uuid()`).
  - `conversation_id` — UUID, foreign key to `od_conversations(id)`.
  - `created_at` — timestamptz (default `now()` or from app).
  - `role` — text: `"instructor"`, `"moderator"`, `"agent1"`, `"agent2"`.
  - `message` — text, the message content.

Create these in the Supabase SQL Editor (one-time), e.g.:

```sql
create table if not exists od_conversations (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now(),
  moderator_name text
);

create table if not exists od_messages (
  id bigserial primary key,
  conversation_id uuid not null references od_conversations(id) on delete cascade,
  created_at timestamptz not null default now(),
  role text not null,
  message text not null
);

create index if not exists od_messages_conversation_id_idx on od_messages(conversation_id);
```

---

## 3. App flow and URL

- **Query param:** Use Streamlit’s `st.query_params` for `conversation_id` (e.g. `?conversation_id=<uuid>`). No need to change the browser path; the “URL” we care about is the query string.
- **After moderator name is submitted (first time, or when starting new):**
  - Generate a new UUID.
  - Insert one row into `od_conversations` (id = that UUID, created_at = now(), moderator_name = current moderator name).
  - Set `st.query_params["conversation_id"] = str(uuid)` and keep moderator name in session; then `st.rerun()` so the rest of the app runs with that conversation_id in the URL.
- **When opening the app with no `conversation_id`:** After moderator name is set, treat as “start new conversation” (create row, set param, rerun).
- **When opening a link that already has `conversation_id` in the URL:** The user must still state their name first (moderator gate). After they submit their name, **load the entire conversation history** for that UUID from `od_messages` into `st.session_state.dialogue` and show the main UI with that history (newest-first). Do **not** create a new conversation in this case. If the conversation doesn’t exist in DB (e.g. invalid or deleted UUID), show an error and offer “New conversation”.

---

## 3b. Open link with conversation UUID (explicit flow)

When someone opens a URL that already contains `?conversation_id=<uuid>`:

1. **First:** Show the moderator name gate (if name not yet set). The user enters and submits their name.
2. **Then:** Do **not** create a new conversation. Fetch all messages for that `conversation_id` from `od_messages`, order by `created_at` asc, and set `st.session_state.dialogue` to that list (each entry: role, message, datetime).
3. **Result:** Main UI shows with the **entire conversation history** for that UUID (displayed in reverse chronological order). The user can continue the conversation or use “New conversation” to start a fresh one.

---

## 4. Session state and init

- Add `conversation_id` to session state (optional UUID string, derived from query param when present).
- In `init_session_state()`:
  - If `st.query_params.get("conversation_id")` is set and valid UUID:
    - Set `st.session_state.conversation_id = that_value`.
    - Do **not** reset `dialogue` by default; instead, after the moderator gate (see below), if we have a conversation_id and dialogue is empty, **load dialogue from Supabase** (see “Loading a conversation”).
  - If no conversation_id in URL and we’re past the moderator gate, we’ll create a new conversation and set the param (so next run has conversation_id).
- When we **create a new conversation** (after name submit or “New conversation” button), set `st.session_state.dialogue = []`, generate UUID, insert into `od_conversations`, set `st.session_state.conversation_id = str(uuid)`, set `st.query_params["conversation_id"] = str(uuid)`, then `st.rerun()`.

---

## 5. Moderator name gate and “first run” behavior

- Keep the existing gate: if moderator name is empty, show the form; on submit, set name and rerun.
- **Immediately after** the moderator name is set (and we’re about to show the main UI):
  - If there is **no** `conversation_id` in the URL (or in session): **create a new conversation** (UUID, insert into `od_conversations` with moderator_name, set query param and session conversation_id, clear dialogue), then rerun.
  - If there **is** a `conversation_id` in the URL: **load conversation** (see below) if we haven’t already (e.g. only load when dialogue is empty and we have conversation_id). Then show main UI.

So: “after stating moderator name → new conversation_id generated (UUID) and included in URL” only when there is no conversation_id in the URL. **When the user opens a link with a conversation UUID in the URL, they state their name, then the entire history for that conversation is loaded** — no new conversation is created.

---

## 6. Persisting each message

- Whenever the app adds an entry to `st.session_state.dialogue` (human message, agent reply, or instructor role-update message), also **insert one row** into `od_messages`:
  - `conversation_id` = current `st.session_state.conversation_id`
  - `created_at` = the same timestamp used in the dialogue entry (or `now()`)
  - `role` = party (e.g. `"instructor"`, `"moderator"`, `"agent1"`, `"agent2"`)
  - `message` = content

Places to add this (single helper used everywhere):
- Human chat message (moderator/instructor).
- Agent replies (after `st.session_state.dialogue.append(("agent1", reply, ...))` and same for agent2).
- Instructor “Updated X’s role” messages (both expander form submit handlers).

Helper signature idea: `_persist_message(conversation_id: str, role: str, message: str, created_at: datetime | None = None)` that inserts into `od_messages`. Call it right after every `dialogue.append(...)` when `conversation_id` is set. If Supabase is unavailable, log and continue (don’t break the app).

---

## 7. Loading a conversation

- When the app runs with a `conversation_id` in the URL and we’re past the moderator gate:
  - If `st.session_state.dialogue` is empty (or we add a flag “loaded_from_db” for this conversation to avoid re-loading every rerun), fetch from Supabase:  
    `select created_at, role, message from od_messages where conversation_id = :id order by created_at asc`.
  - Build `dialogue` as list of `(role, message, datetime_from_created_at)` and set `st.session_state.dialogue = that_list`.
- Display in the right column remains “reverse chronological order” (newest first) via existing `reversed(st.session_state.dialogue)` when `dialogue_newest_first` is True.

---

## 8. Left panel: “Previous conversations”

- **Layout:** Change from a single “left column” to: **sidebar or a left panel** that lists conversations, then the current two-column layout (left = controls, right = history) to the right of it. E.g.:
  - **Option A:** Use `st.sidebar` for “Previous conversations” (list of conversation links/cards). Main area = current left_col + right_col.
  - **Option B:** Three columns: `conv_col, left_col, right_col` with conv_col narrow (e.g. 0.15), left 0.45, right 0.4.

Recommendation: **Option A (sidebar)** so the main layout stays as is and the list is clearly “all previous conversations.”

- **Data:** On each run, fetch from Supabase:  
  `select id, created_at, moderator_name from od_conversations order by created_at desc`  
  (limit e.g. 50).
- **Display:** Show each as a row/card: truncated moderator name or “Conversation” + short date/time; clicking sets `st.query_params["conversation_id"] = id` and reruns so the main area loads that conversation (and we load messages as in §7).
- **“New conversation” button:** In the sidebar (or top of main area). On click: generate new UUID, insert into `od_conversations`, set session dialogue to [], set query param and session conversation_id, rerun.

---

## 9. Supabase client in the app

- **Initialization:** Read `SUPABASE_URL` and `SUPABASE_KEY` from env (or `SUPABASE_SERVICE_ROLE_KEY` if you prefer). Create client once (e.g. module-level or inside a `_get_supabase()` that returns None if URL/key missing), and use it in the helpers below.
- **Helpers:**
  - `_supabase()` → client or None.
  - `_create_conversation(moderator_name: str) -> str` → creates row in `od_conversations`, returns conversation_id (UUID string).
  - `_list_conversations(limit: int = 50) -> list[dict]` → list of `{id, created_at, moderator_name}` sorted by created_at desc.
  - `_load_messages(conversation_id: str) -> list[tuple]` → list of (role, message, datetime) in chronological order.
  - `_persist_message(conversation_id: str, role: str, message: str, created_at: datetime | None = None)` → insert one row into `od_messages`.
- If `_supabase()` is None (missing URL/key), all these no-op or return empty/default so the app still runs without Supabase.

---

## 10. Edge cases

- **Invalid or missing conversation_id in URL:** If user tampers with the param or the conversation was deleted, on load we get no rows. Treat as “empty conversation” or show a short message and offer “Start new conversation” (same as New conversation button).
- **New conversation without moderator name:** We don’t create a conversation until after the moderator name is submitted; the “new conversation” creation happens only when we have a name and no conversation_id (or when user clicks “New conversation”).
- **Duplicate messages:** Persist only when we actually append to `dialogue` (one insert per append). No need to “sync entire dialogue” on every run if we always persist on append; loading is only for when we open an existing conversation_id.

---

## 11. File and code changes summary

| Area | Change |
|------|--------|
| `pyproject.toml` | Add `supabase` dependency. |
| `.env` | Add `SUPABASE_URL` (you have `SUPABASE_KEY`). |
| Supabase Dashboard | Run SQL above to create `od_conversations` and `od_messages`. |
| `app.py` | Import supabase, add `_get_supabase()`, `_create_conversation`, `_list_conversations`, `_load_messages`, `_persist_message`. |
| `app.py` | `init_session_state`: add `conversation_id` from query param when present. |
| `app.py` | After moderator name gate: if no conversation_id → create new conversation, set param, rerun; if conversation_id and dialogue empty → load messages from DB. |
| `app.py` | After every `dialogue.append(...)`: call `_persist_message(...)`. |
| `app.py` | Add sidebar: list conversations (from `_list_conversations`), “New conversation” button; on conversation click set query param and rerun. |
| `app.py` | Optional: show current conversation_id in the UI (e.g. in sidebar or as caption). |

---

## 12. Table naming note

You asked for “a new table od_<conversation_id>” per conversation. This plan uses one **messages** table `od_messages` with `conversation_id` instead, so we can list all conversations from `od_conversations` and query messages by `conversation_id`. If you specifically need a separate physical table per conversation (e.g. `od_a1b2c3d-...`), we can add a step that runs `CREATE TABLE od_<uuid> (...)` via raw SQL when a conversation is created and then insert messages into that table; listing conversations would still use `od_conversations`. The behavior (one conversation_id, one set of messages, list all conversations) is the same either way.
